# Update 3迭代思路（11.27）
想来在Update2中为了UI界面的实现，很多地方的面向对象不是很正确。
比如虽然把地图的位置每个用JButton来表示，但是如果下文中使用到了
对当前情况的判断，就不容易读取到当前的状态，所以仔细想来仍是需要
一个类似二维数组的结构来储存当前的状态。  
这个二维数组使用泛型实现最为恰当，因为实际上向这个二维数组里面添加
的不只是Creature类，还有可能是其他的比如石头？炸药？陷阱？这些
未来可能会填充的东西。  
所以还是多加一个BattleField的类。这个用来反映战场信息。Creature
得到战场的信息应该从BattleField中信息传递得到而非UI。 

除此之外，将God、Evil中葫芦娃等具体人物的枚举类改成对应的子类，
便于添加了Cheer接口给GrandPa和Snake类，区分开不同的人不同技能。 

## 新增Rock类及文件读取功能 
新增了Rock类，独立于Creature类，但是一样有Identity接口，用于
识别自己的身份。引入的目的是为了丰富化地图。  
利用上课所学相关文件读取，添加了文件读取的功能，使得能够读取不同的地图。
地图读取功能是在初始化的时候在Battlefield中实现。 
## 再一次理解故事情节？ 
从理解的角度上看，这是一个世界。程序员是上帝（或者说脑子？意识？）
God、Evil代表好坏两类，均是生物所创，他们约定在BattleField中
决战，所以God、Evil中操作的只能是自我派兵布置阵法，这些都是向BattleField
中传递，而BattleFiele再向UI中反映出来。  
可以理解我们在UI界面的输入信息（这里本可以引用文本输入输出部分，后来
觉得好像相关性不是很大，有了界面工具就省去了这部分功能的使用），输入信息
是God、Evil的想法（Listener），这种想法直接作用于排兵布阵。排兵布阵对BattleField
进行了修改，而这种修改由UI来表现。       
综合上面，对类之间的关系又加多了几分理解。

## 不足之处 
在这个设计中，各个类之间的耦合度很大，不是好的设计。主要原因是UI和抽象的
二位存储空间是分开的类，逻辑上也没有继承关系，但彼此又是相互制约的。  
目前想到的一个解决方法是需要用一个static 全局的变量作为二维数组的存储，
这样能够降低耦合度。时间有限，只能在接下来的程序中做大的迭代了。 

## 总结 
提供了一个可执行jar包，可直接运行。   
# 以前的修改（可不看） 

# Update2 

## 10.31更新 
1. 添加了图形界面 
2. 修改了README，重新审视了代码结构，在strategy中利用Map容器类型 

## 思路（UML图） 
UML图如下： 
![对象图](uml.png)  
有三个由广义的Object类的子类：界面（UI）、阵法（Strategy）、生物体（Creature）。  
界面负责显示用户页面，并且反馈使用者的需求（即请求摆出什么阵型），然后将需求信息传递给生物体处理。 
生物体收到信息后决定采取对应的阵法。向阵法类发送信息，获得阵法的相关坐标，经过处理后将需要显示的信息发送给UI。 
阵法类就是负责反馈阵法信息。 
这样处理的好处是将功能分发给不同的对象，每个对象相互独立，有不同的职责，
## 深入各个类
### UI 
![对象图](ui.png)  
UI主要负责界面显示，所以主要处理Frame上控件的初始化，
以及能够提供一个能修改一定地址摆放的人物的函数。  

UI中棋盘中每个棋盘由一个按键对象相对应，一个对象显示一个格子。  

UI接受使用者传来的调度信息，并传达给Creature类。
也提供了响应Creature类，一系列与显示有关的函数。 
 
### Creature 
1、父类默认构造函数为“草”，这样能够提供最基本的访问。   

2、子类God和Evil均可以向UI传递信息，向战场中安排生物体。选择子类实现是因为两者不同点较多，可以方便以后对两者区分修改。比如为两者加上不同的技能。   

3、选择用继承方式实现的原因：一方面是两者之间有逻辑上的继承关系，便于理解，另一方面是两者之间共同点较多，
用接口不便于处理，而且继承方便下一步的扩展。  

4、子类可以与Strategy类、UI类发送信息交流。  

5.为了区分，God表示的好人不会出现妖怪的头像，结合之前的经验，使用enum类可以保证这类错误不会发生。   

| God | enum类型 |  evil | enum类型 |
| ------ | ------ | ------ | ------ |
| 葫芦娃 | HERO | 小喽啰 | UGLY |
| 爷爷 | GRANDPA | 蛇精 | BOSS|
### Strategy  
![对象图](Strategy.png) 
1、按照阵法要求，返回地图中某点是否需要派兵  

2、返回阵法中统领的X、Y坐标  

3、strategy作为抽象类，下面的子类是各个不同阵法。
利用继承关系可以复写父类中的函数，所以能实现不同的阵法效果。
实际上我觉得在这里使用接口也可以。   

## 实现结果 
![实例图](result.png) 

## 实现细节亮点
1、虽然在God、Evil都有类似的private量，但是通过实现不同的enum枚举变量，避免出现两者混合的错误  
2、利用不同的方法比如Map、数组来储存阵法信息  
3、继承的广泛使用为后续的修改留有余地，便于接下来给葫芦娃和妖怪不同的技能  

  
